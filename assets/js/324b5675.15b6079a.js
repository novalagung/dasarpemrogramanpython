"use strict";(self.webpackChunkdasarpemrogramanpython=self.webpackChunkdasarpemrogramanpython||[]).push([[5272],{3905:(a,e,t)=>{t.d(e,{Zo:()=>o,kt:()=>k});var n=t(7294);function r(a,e,t){return e in a?Object.defineProperty(a,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):a[e]=t,a}function i(a,e){var t=Object.keys(a);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(a);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(a,e).enumerable}))),t.push.apply(t,n)}return t}function l(a){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?i(Object(t),!0).forEach((function(e){r(a,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(a,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(e){Object.defineProperty(a,e,Object.getOwnPropertyDescriptor(t,e))}))}return a}function s(a,e){if(null==a)return{};var t,n,r=function(a,e){if(null==a)return{};var t,n,r={},i=Object.keys(a);for(n=0;n<i.length;n++)t=i[n],e.indexOf(t)>=0||(r[t]=a[t]);return r}(a,e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(a);for(n=0;n<i.length;n++)t=i[n],e.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(a,t)&&(r[t]=a[t])}return r}var u=n.createContext({}),p=function(a){var e=n.useContext(u),t=e;return a&&(t="function"==typeof a?a(e):l(l({},e),a)),t},o=function(a){var e=p(a.components);return n.createElement(u.Provider,{value:e},a.children)},c="mdxType",d={inlineCode:"code",wrapper:function(a){var e=a.children;return n.createElement(n.Fragment,{},e)}},m=n.forwardRef((function(a,e){var t=a.components,r=a.mdxType,i=a.originalType,u=a.parentName,o=s(a,["components","mdxType","originalType","parentName"]),c=p(t),m=r,k=c["".concat(u,".").concat(m)]||c[m]||d[m]||i;return t?n.createElement(k,l(l({ref:e},o),{},{components:t})):n.createElement(k,l({ref:e},o))}));function k(a,e){var t=arguments,r=e&&e.mdxType;if("string"==typeof a||r){var i=t.length,l=new Array(i);l[0]=m;var s={};for(var u in e)hasOwnProperty.call(e,u)&&(s[u]=e[u]);s.originalType=a,s[c]="string"==typeof a?a:r,l[1]=s;for(var p=2;p<i;p++)l[p]=t[p];return n.createElement.apply(null,l)}return n.createElement.apply(null,t)}m.displayName="MDXCreateElement"},8798:(a,e,t)=>{t.r(e),t.d(e,{assets:()=>u,contentTitle:()=>l,default:()=>d,frontMatter:()=>i,metadata:()=>s,toc:()=>p});var n=t(7462),r=(t(7294),t(3905));const i={sidebar_position:41,title:"A.41. Python Duck Typing vs Structural Typing",sidebar_label:"A.41. Duck Typing vs. Structural Typing"},l=void 0,s={unversionedId:"basic/duck-typing-vs-structural-typing",id:"basic/duck-typing-vs-structural-typing",title:"A.41. Python Duck Typing vs Structural Typing",description:"Pada chapter ini kita akan belajar salah satu konsep yang ada di bahasa pemrograman dinamis, yaitu duck typing, beserta perbandingannya dengan structural typing",source:"@site/docs/basic/duck-typing-vs-structural-typing.md",sourceDirName:"basic",slug:"/basic/duck-typing-vs-structural-typing",permalink:"/basic/duck-typing-vs-structural-typing",draft:!1,tags:[],version:"current",sidebarPosition:41,frontMatter:{sidebar_position:41,title:"A.41. Python Duck Typing vs Structural Typing",sidebar_label:"A.41. Duck Typing vs. Structural Typing"},sidebar:"tutorialSidebar",previous:{title:"A.40. OOP \u279c Abstract Method",permalink:"/basic/abstract-method"},next:{title:"A.42. Error & Exception",permalink:"/basic/error-exception"}},u={},p=[{value:"A.41.1. Duck typing",id:"a411-duck-typing",level:2},{value:"\u25c9 Skenario 1: Instance method",id:"-skenario-1-instance-method",level:3},{value:"\u25c9 Skenario 2: Attribute berisi closure",id:"-skenario-2-attribute-berisi-closure",level:3},{value:"\u25c9 Skenario 3: Attribute berisi lambda",id:"-skenario-3-attribute-berisi-lambda",level:3},{value:"\u25c9 Skenario 4: Class method",id:"-skenario-4-class-method",level:3},{value:"A.41.2. Structural typing",id:"a412-structural-typing",level:2},{value:"Catatan chapter \ud83d\udcd1",id:"catatan-chapter-",level:2},{value:"\u25c9 Source code praktik",id:"-source-code-praktik",level:3},{value:"\u25c9 Chapter relevan lainnya",id:"-chapter-relevan-lainnya",level:3},{value:"\u25c9 Referensi",id:"-referensi",level:3}],o={toc:p},c="wrapper";function d(a){let{components:e,...i}=a;return(0,r.kt)(c,(0,n.Z)({},o,i,{components:e,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Pada chapter ini kita akan belajar salah satu konsep yang ada di bahasa pemrograman dinamis, yaitu ",(0,r.kt)("strong",{parentName:"p"},"duck typing"),", beserta perbandingannya dengan ",(0,r.kt)("strong",{parentName:"p"},"structural typing")),(0,r.kt)("h2",{id:"a411-duck-typing"},"A.41.1. Duck typing"),(0,r.kt)("p",null,"Istilah ",(0,r.kt)("em",{parentName:"p"},"duck typing")," berasal dari kalimat ",(0,r.kt)("em",{parentName:"p"},"If it looks like a duck and quacks like a duck, it's a duck"),"."),(0,r.kt)("p",null,"Duck typing adalah konsep yang menjelaskan bahwa compiler/interpreter tidak perlu tau apakah suatu fungsi itu merupakan method, lambda, atau berasal dari class tertentu, atau apapun lainnya; selama fungsi tersebut saat diakses memenuhi kriteria (nama dan skema parameter-nya sama) maka fungsi dianggap valid secara logika."),(0,r.kt)("p",null,"Mari kita praktekan agar lebih jelas maksudnya apa. Pertama, siapkan sebuah fungsi bernama ",(0,r.kt)("inlineCode",{parentName:"p"},"do_the_math()"),". Tugas fungsi ini sangat sederhana, yaitu menerima parameter ",(0,r.kt)("inlineCode",{parentName:"p"},"obj"),", kemudian lewat variabel tersebut method ",(0,r.kt)("inlineCode",{parentName:"p"},"calculate_area()")," diakses."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'def do_the_math(obj):\n    area = obj.calculate_area()\n    print(f"area of {type(obj).__name__}: {area}")\n')),(0,r.kt)("p",null,"Selanjutnya adalah bagian terpenting dari pembelajaran di chapter ini, fungsi yang sudah dibuat akan di test menggunakan beberapa skenario."),(0,r.kt)("h3",{id:"-skenario-1-instance-method"},"\u25c9 Skenario 1: Instance method"),(0,r.kt)("p",null,"Buat class baru untuk operasi perhitungan luas segitiga. Operasi perhitungannya disiapkan di instance method bernama ",(0,r.kt)("inlineCode",{parentName:"p"},"calculate_area()"),". Dari sini, object buatan class ini harusnya bisa dipergunakan sebuagai argument fungsi ",(0,r.kt)("inlineCode",{parentName:"p"},"do_the_math()"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"class Triangle:\n    def __init__(self, b, h):\n        self.b = b\n        self.h = h\n\n    def calculate_area(self):\n        return 1/2 * self.b * self.h\n\nobj1 = Triangle(4, 10)\ndo_the_math(obj1)\n# output \u279c area of Triangle: 20.0\n")),(0,r.kt)("p",null,"Hasilnya: OK \u2705"),(0,r.kt)("h3",{id:"-skenario-2-attribute-berisi-closure"},"\u25c9 Skenario 2: Attribute berisi closure"),(0,r.kt)("p",null,"Berikutnya, siapkan class baru lagi dengan attribute bernama ",(0,r.kt)("inlineCode",{parentName:"p"},"calculate_area"),", lalu isi nilai attribute tersebut dengan closure. Disini dicontohkan closure-nya adalah fungsi ",(0,r.kt)("inlineCode",{parentName:"p"},"number_10()")," yang tugasnya mengembalikan nilai numerik ",(0,r.kt)("inlineCode",{parentName:"p"},"10"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"def number_10():\n    return 10\n\nclass AreaOf2x10:\n    def __init__(self) -> None:\n        self.calculate_area = number_10\n\nobj2 = AreaOf2x10()\ndo_the_math(obj2)\n# output \u279c area of AreaOf2x10: 10\n")),(0,r.kt)("p",null,"Hasilnya: OK \u2705"),(0,r.kt)("p",null,"Fungsi ",(0,r.kt)("inlineCode",{parentName:"p"},"do_the_math()")," berjalan sesuai harapan tanpa melihat tipe data dan struktur dari argument-nya seperti apa. Selama argument memiliki property bernama ",(0,r.kt)("inlineCode",{parentName:"p"},"calculate_area")," dan bisa diakses dalam bentuk notasi fungsi, maka bukan masalah."),(0,r.kt)("h3",{id:"-skenario-3-attribute-berisi-lambda"},"\u25c9 Skenario 3: Attribute berisi lambda"),(0,r.kt)("p",null,"Pada skenario ini, sebuah class bernama ",(0,r.kt)("inlineCode",{parentName:"p"},"AreaOfRandomInt")," dibuat disertai dengan attribute bernama ",(0,r.kt)("inlineCode",{parentName:"p"},"calculate_area")," yang berisi operasi perkalian angka random yang ditulis dalam syntax lambda."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"import random\n\nclass AreaOfRandomInt:\n    def __init__(self) -> None:\n        self.calculate_area = lambda : random.randint(0, 10) * 2\n\nobj3 = AreaOfRandomInt()\ndo_the_math(obj3)\n# output \u279c 16\n")),(0,r.kt)("p",null,"Hasilnya: OK \u2705"),(0,r.kt)("h3",{id:"-skenario-4-class-method"},"\u25c9 Skenario 4: Class method"),(0,r.kt)("p",null,"Bisa dibiliang seknario ini yang paling unik. Buat sebuah class baru berisi class method ",(0,r.kt)("inlineCode",{parentName:"p"},"calculate_area()"),". Lalu jadikan class tersebut sebagai argument pemanggilan fungsi ",(0,r.kt)("inlineCode",{parentName:"p"},"do_the_math()"),". Jadi disini kita tidak menggunakan instance object sama sekali."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'class NotReallyA2dObject:\n    @classmethod\n    def calculate_area(cls):\n        return "where is the number?"\n\ndo_the_math(NotReallyA2dObject)\n# output \u279c where is the number?\n')),(0,r.kt)("p",null,"Hasilnya: OK \u2705"),(0,r.kt)("p",null,"Fungsi ",(0,r.kt)("inlineCode",{parentName:"p"},"do_the_math()")," tetap bisa menjalankan tugasnya dengan baik, bahkan untuk argument yang bukan instance object sekalipun. Selama argument memiliki fungsi ",(0,r.kt)("inlineCode",{parentName:"p"},"calculate_area()")," maka semuanya aman terkendali."),(0,r.kt)("h2",{id:"a412-structural-typing"},"A.41.2. Structural typing"),(0,r.kt)("p",null,"Structural typing bisa diibartkan sebagai duck typing tapi versi yang lebih ketat. Structural typing mengharuskan suatu fungsi atau method untuk memilki spesifikasi yang sama persis sesuai yang dideklarasikan. Misalnya ada suatu object berisi method dengan hanya nama fungsi dan skema parameternya saja yang sama dibanding yang dibutuhkan, maka itu tidak cukup dan error pasti muncul."),(0,r.kt)("p",null,"Cara penerapan structural typing adalah dengan menentukan tipe data parameter secara ",(0,r.kt)("em",{parentName:"p"},"explicit"),". Mari coba praktekan via kode berikut agar lebih jelas."),(0,r.kt)("p",null,"Pertama, siapkan sebuah class bernama ",(0,r.kt)("inlineCode",{parentName:"p"},"Object2D")," yang memiliki abstract method ",(0,r.kt)("inlineCode",{parentName:"p"},"calculate_area()"),". Lalu buat juga fungsi ",(0,r.kt)("inlineCode",{parentName:"p"},"do_the_math()")," tapi kali ini argument nya bertipe data ",(0,r.kt)("inlineCode",{parentName:"p"},"Object2D"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'from abc import ABC, abstractmethod\n\nclass Object2D(ABC):\n    @abstractmethod\n    def calculate_area(self):\n        pass\n\ndef do_the_math(obj: Object2D):\n    area = obj.calculate_area()\n    print(f"area of {type(obj).__name__}: {area}")\n')),(0,r.kt)("p",null,"Dari sini terlihat bahwa untuk bisa menggunakan fungsi ",(0,r.kt)("inlineCode",{parentName:"p"},"do_the_math()")," data argument harus bertipe ",(0,r.kt)("inlineCode",{parentName:"p"},"Object2D")," atau class turunannya. Inilah bagaimana structural typing diaplikasikan di Python."),(0,r.kt)("p",null,"Selanjutnya, buat class implementasinya, tak lupa panggil fungsi ",(0,r.kt)("inlineCode",{parentName:"p"},"do_the_math()"),", dan isi argument-nya menggunakan instance object. Jalankan program, hasilnya tidak akan error, karena saat pemanggilan fungsi ",(0,r.kt)("inlineCode",{parentName:"p"},"do_the_math()")," argument yang disisipkan tipe datanya sesuai spesifikasi, yaitu bertipe ",(0,r.kt)("inlineCode",{parentName:"p"},"Object2D")," atau class turunannya. "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"class Triangle(Object2D):\n    def __init__(self, b, h):\n        self.b = b\n        self.h = h\n\n    def calculate_area(self):\n        return 1/2 * self.b * self.h\n\nclass Circle(Object2D):\n    def __init__(self, r):\n        self.r = r\n\n    def calculate_area(self):\n        return 3.14 * self.r * self.r\n\nclass Square(Object2D):\n    def __init__(self, s):\n        self.s = s\n    \n    def calculate_area(self):\n        return self.s * self.s\n\ndo_the_math(Triangle(4, 10))\n# output \u279c area of Triangle: 20.0\n\ndo_the_math(Circle(20))\n# output \u279c area of Circle: 1256.0\n\ndo_the_math(Square(6))\n# output \u279c area of Square: 36\n")),(0,r.kt)("p",null,"Selanjutnya, coba test fungsi ",(0,r.kt)("inlineCode",{parentName:"p"},"do_the_math()")," menggunakan argument berisi data yang bukan bertipe ",(0,r.kt)("inlineCode",{parentName:"p"},"Object2D")," dan juga bukan turunannya."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'class NotReallyA2dObject:\n    @classmethod\n    def calculate_area(cls):\n        return "where is the number?"\n\ndo_the_math(NotReallyA2dObject)\n')),(0,r.kt)("p",null,"Silakan cek di editor masing-masing, pada statement ",(0,r.kt)("inlineCode",{parentName:"p"},"do_the_math()")," terlihat ada warning."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Duck typing vs structural typing",src:t(9109).Z,width:"810",height:"183"})),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Python merupakan bahasa pemrograman dinamis yang dukungan terhadap structural typing tidak terlalu bagus. Keterangan tidak valid pada gambar di atas hanyalah warning, tidak benar-benar error. Kode program sendiri tetap bisa dijalankan.")),(0,r.kt)("hr",null),(0,r.kt)("div",{class:"section-footnote"},(0,r.kt)("h2",{id:"catatan-chapter-"},"Catatan chapter \ud83d\udcd1"),(0,r.kt)("h3",{id:"-source-code-praktik"},"\u25c9 Source code praktik"),(0,r.kt)("pre",null,(0,r.kt)("a",{href:"https://github.com/novalagung/dasarpemrogramanpython-example/tree/master/duck-typing-vs-structural-typing"},"github.com/novalagung/dasarpemrogramanpython-example/../duck-typing-vs-structural-typing")),(0,r.kt)("h3",{id:"-chapter-relevan-lainnya"},"\u25c9 Chapter relevan lainnya"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/basic/tipe-data"},"Tipe Data")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/basic/abstract-method"},"OOP \u279c Abstract Method"))),(0,r.kt)("h3",{id:"-referensi"},"\u25c9 Referensi"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://stackoverflow.com/questions/4205130/what-is-duck-typing"},"https://stackoverflow.com/questions/4205130/what-is-duck-typing")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://docs.python.org/3/glossary.html#term-duck-typing"},"https://docs.python.org/3/glossary.html#term-duck-typing")))))}d.isMDXComponent=!0},9109:(a,e,t)=>{t.d(e,{Z:()=>n});const n=t.p+"assets/images/duck-typing-vs-structural-typing-1-774e8fa9cd43e25c03ee7ade8d07391f.png"}}]);